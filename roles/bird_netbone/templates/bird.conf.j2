log syslog all;
#Router ID (hier v4)
router id {{router_ip | ipaddr('address')}};

#interne BIRD Routing-Tabelle
table ibgp;
table interior;
table ffwp;
table icvpn;
table ffrl;
table inetexit;

define ffrl_nat_address = {{server_ipv4_nat | ipaddr('address')}};
define router_ip = {{router_ip | ipaddr('address')}};
define ownas = {{ff_network.as_number}};

function is_ffwp_ffrl_nets() {
  return net ~ [
  185.66.194.18/31{31,32},
  185.66.195.18/31{31,32}
  ];
}

#In Funktionen Variablen nicht möglich
function is_ffrl_nat() {
  return net ~ [
  {{server_ipv4_nat | ipaddr('address')}}/32
  ];
}

function is_ffwp() {
    return net ~ [
    10.198.0.0/16+
    ];
}

function is_default() {
        return (net ~ [0.0.0.0/0]);
};

protocol device {
        scan time 10;
};

#Kopiere gelernte Routen aus FFRL in Main Tabelle
protocol pipe pipe_main_ffrl {
  peer table ffrl;
  #Source Adresse setzen
  import filter {
      krt_prefsrc = ffrl_nat_address;
      if is_default() then accept;
      reject;
  };
  export none;
};

#Kopiere Routen aus Main in die inetexit Tabelle
protocol pipe pipe_main_inetexit {
  peer table inetexit;
  import none;
  export filter {
      if is_default() then accept;
      #todo: ggf. auch andere Public Netze
      reject;
  };
};

protocol pipe pipe_main_ffwp {
  peer table ffwp;
  import none;
  export filter {
    if is_ffwp() then accept;
    reject;
  };
};

protocol pipe pipe_main_interior {
  peer table interior;
  import filter {
      if is_ffwp() then accept;
      reject;
  };
  export none;
};

#Kopiere alle Routen bis auf FFWP und Default Routen in iBGP Tabelle
protocol pipe pipe_main_ibgp {
  peer table ibgp;
  import all;
  export where !is_ffwp() && !is_default();
};


# IP-NAT-Adresse legen wir in die interne BIRD Routing Table
protocol static ffrl_uplink_hostroute {
    table ffrl;
    route ffrl_nat_address/32 reject;
}

protocol kernel kernel_ffwp {
  scan time 10;
  #Auch Device Routen in Tabelle eintragen da benötigt und durch rules kein kontakt zur Main Routing Tabelle
  device routes;
  import none;
  export filter {
    krt_prefsrc = router_ip;
    if is_ffwp() then accept;
    reject;
  };
  table ffwp;
  kernel table 40;
};

#todo: ICVPN

#Routen aus inetexit in die Kernel Table 42 (ffinetexit) schreiben
protocol kernel kernel_inetexit {
  #Auch Device Routen in Tabelle eintragen da benötigt und durch rules kein kontakt zur Main Routing Tabelle
#  device routes;
  scan time 10;
  import none;
  export all;
  table inetexit;
  kernel table 42;
};

#Tabelle um OSPF auf keinen Fall zu brechen
protocol kernel kernel_interior {
  scan time 10;
  #Auch Device Routen in Tabelle eintragen da benötigt und durch rules kein Kontakt zur Main Routing Tabelle
  device routes;
  import none;
  export filter {
    krt_prefsrc = router_ip;
    #Default Routen nicht erwünscht, Rest aufnehmen
    if is_default() then reject;
    accept;
  };
  table interior;
  kernel table 43;
};

protocol ospf IGP {
  area 0 {
        interface "ffwp_*";
        interface "int_*";
        interface "eth1";
        stubnet router_ip/32;
        #Default Route
        stubnet 0.0.0.0/0;
  };
        stub router no;         # Box macht ggf. auch Transit-Traffic
        ecmp no;                # Kein Equal-Cost-Multipath, um Problemen mit unterschiedlichen
                                # Uplinks aus dem Weg zu gehen
        table interior;
        import keep filtered;
        #Wir wollen alles bis auf Default Routen importieren
        import filter{
          if is_default() then reject;
          accept;
        };
        #Keine Routen von anderen Quellen per OSPF propagieren
        export none;
};


# Uplink über ff Rheinland
template bgp ffrl_uplink {
        table ffrl;
        local as ownas;
        import keep filtered;
        import filter {
          if is_default() then accept;
          reject;
        };
        export filter {
          if is_ffrl_nat() then accept;
          reject;
        };
        next hop self;
        direct;
#       multihop 64;
#       default bgp_local_pref 200;
};

# ibgp zwischen den gateways
template bgp internal {
        table ibgp;
        source address router_ip;
        local as ownas;
        import filter {
                bgp_path.prepend(ownas);
                preference = 99;
                accept;
        };
        export where source = RTS_BGP;
        next hop self;
#von vielen Communitys benutzt macht hier aber Dinge kaputt, wegen OSPF wohl multihop
#        gateway direct;
#        direct;
};


# hier jeweils ein Eintrag zu jedem der anderen Gateways

{% for host in groups['bgp'] %}
{% if  hostvars[host]['inventory_hostname'] is not equalto inventory_hostname %}
protocol bgp internal_{{ hostvars[host]['inventory_hostname'] }} from internal {
  neighbor {{ hostvars[host]['router_ip'] | regex_replace("^(\d+\.\d+\.\d+\.\d+)/\d+$","\\1") }} as {{ff_network.as_number}};
};
{% endif %}
{% endfor %}


#mit local_pref ggf. Uplinks bevorzugen
# Todo: durch das /31 funktioniert ipaddr() nicht korrekt, klären, ob /31 in der config entfernt werden kann und dann regex entfernen
{% for gre in ffrl_gre %}
protocol bgp ffrl_{{gre.name}} from ffrl_uplink {
  source address {{gre.v4_local | ipaddr('address')}};
  neighbor {{gre.v4_remote | regex_replace("^(\d+\.\d+\.\d+\.\d+)/\d+$","\\1")}} as 201701;
{% if loop.first %}
  default bgp_local_pref 201;
  default bgp_med 1;
{% endif %}
};

{% endfor %}
